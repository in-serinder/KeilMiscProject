C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 04:28:17 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <Ser.h>
   2          #include <Timer.h>
   3          #include <stdio.h>
   4          #include <Util.h>
   5          #include <Max7219.h>
   6          #include <TM1637.h>
   7          
   8          /* ----串口消息格式----
   9           *时间戳: 2023-10-24-16:00:00^
  10           *继电器状态 000^
  11           *温湿度 00.00^00.00^
  12           *完全格式 2023-10-24-16:00:00^000^00.00^00.00^
  13           */
  14          
  15          sbit Relay1 = P0 ^ 3;
  16          sbit Relay2 = P0 ^ 2;
  17          sbit Relay3 = P0 ^ 4;
  18          
  19          sbit RelayLED1 = P1 ^ 1;
  20          sbit RelayLED2 = P1 ^ 2;
  21          sbit RelayLED3 = P1 ^ 4;
  22          sbit WarnLed = P1 ^ 7;
  23          
  24          sbit infrared = P1 ^ 3;
  25          
  26          sbit RelayButton = P0 ^ 0;
  27          sbit SettingButton = P0 ^ 1;
  28          
  29          sbit BuzzerS1 = P0 ^ 0;
  30          
  31          void main()
  32          {
  33   1          char xdata *msg, *timestr;
  34   1          struct UtilOBJ xdata dat;
  35   1          // unsigned char time;
  36   1          unsigned char i;
  37   1          unsigned char *IRdata;
  38   1          unsigned char xdata relaySetPos = 1, Timercount = 0;
  39   1          int xdata timecount = 0;
  40   1          bit dateOrTempFlag = 0;
  41   1          bit bitlogrelay = 0;
  42   1          bit settingflag = 0;
  43   1          bit flip = 0;
  44   1      
  45   1          ///////////////////////////////////////////
  46   1          UART_Init();
  47   1          // 初始化串口
  48   1          TM1637_Init();
  49   1          Max7219_Init();
  50   1      
  51   1          InitExternalInterrupt0();
  52   1      
  53   1          Relay1 = 0;
  54   1          Relay2 = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 04:28:17 PAGE 2   

  55   1          Relay3 = 0;
  56   1          RelayLED1 = 0;
  57   1          RelayLED2 = 0;
  58   1          RelayLED3 = 0;
  59   1          WarnLed = 0;
  60   1          BuzzerS1 = 0;
  61   1      
  62   1          //////////////////////////////////////////
  63   1      
  64   1          UART_SendString("51 Ready!\r\n");
  65   1      
  66   1          //////////////////////////////////////////
  67   1          while (1)
  68   1          {
  69   2      
  70   2              timecount++;
  71   2              // UART_SendString("Hello, World!\r\n");
  72   2              if (getRec())
  73   2              {
  74   3                  msg = getData();
  75   3                  dat = getUtil(msg);
  76   3      
  77   3                  // sprintf(timestr, "%d", ((dat.Time[0] - '0') * 10 + (dat.Time[1] - '0')) * 100 + ((dat.Time[
             -2] - '0') * 10 + (dat.Time[3] - '0')));
  78   3                  sprintf(timestr, "%d%d%d%d", dat.Time[0], dat.Time[1], dat.Time[2], dat.Time[3]);
  79   3      
  80   3                  // time = ((dat.Time[0] - '0') * 10 + (dat.Time[1] - '0')) * 100 + ((dat.Time[2] - '0') * 10 +
             - (dat.Time[3] - '0'));
  81   3      
  82   3                  //////////////////////////////////////
  83   3                  UART_SendString(msg);
  84   3                  UART_SendString(timestr);
  85   3                  UART_SendChar('\n');
  86   3                  // UART_SendString(dat.Relay1);
  87   3                  UART_SendChar(dat.Relay1 ? '1' : '0');
  88   3                  UART_SendChar('\n');
  89   3                  // UART_SendString(dat.Relay2);
  90   3                  UART_SendChar(dat.Relay2 ? '1' : '0');
  91   3                  UART_SendChar('\n');
  92   3                  // UART_SendString(dat.Relay3);
  93   3                  UART_SendChar(dat.Relay3 ? '1' : '0');
  94   3                  UART_SendChar('\n');
  95   3      
  96   3                  // Max7921StringDisplay(dat.Date);
  97   3                  // Max7219StringDisplay(dat.Date);
  98   3                  /*时间与温湿度*/
  99   3                  // Max7219TemperatureAndHumitidyDisplay(dat.Temperature, dat.Humidity);
 100   3                  if (dateOrTempFlag)
 101   3                  {
 102   4                      Max7219DateDisplay(dat.Date);
 103   4                  }
 104   3                  else
 105   3                  {
 106   4                      Max7219TemperatureAndHumitidyDisplay(dat.Temperature, dat.Humidity);
 107   4                  }
 108   3      
 109   3                  if (timecount % 10 == 0)
 110   3                  {
 111   4                      dateOrTempFlag = !dateOrTempFlag;
 112   4                  }
 113   3      
 114   3                  // TM1637_Display4Num(time, flip);
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 04:28:17 PAGE 3   

 115   3                  TM1637_StringDisplay(dat.Time, flip);
 116   3                  flip = !flip; // 翻转显示时间冒号
 117   3                  ClearBuffer();
 118   3      
 119   3                  // Max7219_Clear();
 120   3                  /*继电器*/
 121   3                  Relay1 = dat.Relay1;
 122   3                  Relay2 = dat.Relay2;
 123   3                  Relay3 = dat.Relay3;
 124   3                  /*继电器灯光继承*/
 125   3                  RelayLED1 = Relay1;
 126   3                  RelayLED2 = Relay2;
 127   3                  RelayLED3 = Relay3;
 128   3              }
 129   2      
 130   2              if (getIRFlag())
 131   2              {
 132   3                  IRdata = getIRData();
 133   3      
 134   3                  // 发送标题
 135   3                  UART_SendString("IR Code: ");
 136   3      
 137   3                  // 逐个字节转换为16进制字符串发送
 138   3                  for (i = 0; i < 4; i++)
 139   3                  {
 140   4                      // 发送高4位
 141   4                      UART_SendChar((IRdata[i] >> 4) < 10 ? (IRdata[i] >> 4) + '0' : (IRdata[i] >> 4) + 'A' - 10
             -);
 142   4                      // 发送低4位
 143   4                      UART_SendChar((IRdata[i] & 0x0F) < 10 ? (IRdata[i] & 0x0F) + '0' : (IRdata[i] & 0x0F) + 'A
             -' - 10);
 144   4                      UART_SendChar(' ');
 145   4                  }
 146   3      
 147   3                  UART_SendString("\r\n"); // 换行
 148   3              }
 149   2      
 150   2              /*处理按钮调节*/
 151   2              if (SettingButton)
 152   2              {
 153   3                  settingflag = 1;
 154   3                  Timercount = 0;                   // 重置计时器
 155   3                  dateOrTempFlag = !dateOrTempFlag; // 直接翻转
 156   3                  dat.WarnFlag = 0;
 157   3              }
 158   2              // 警告状态
 159   2              if (dat.WarnFlag)
 160   2              {
 161   3                  WarnLed = 1;
 162   3                  BuzzerS1 = 1;
 163   3              }
 164   2              else
 165   2              {
 166   3                  WarnLed = 0;
 167   3                  BuzzerS1 = 0;
 168   3              }
 169   2      
 170   2              if (settingflag)
 171   2              {
 172   3                  Delay_ms(1000); // 处于设置模式时延时
 173   3                  WarnLed = 1;
 174   3                  Timercount++;
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 04:28:17 PAGE 4   

 175   3      
 176   3                  relaySetPos++;
 177   3                  if (relaySetPos >= 3)
 178   3                  {
 179   4                      relaySetPos = 1;
 180   4                  }
 181   3      
 182   3                  switch (relaySetPos)
 183   3                  {
 184   4                  case 1:
 185   4                      RelayLED1 = 1;
 186   4                      RelayLED2 = 0, RelayLED3 = 0;
 187   4                      break;
 188   4                  case 2:
 189   4                      RelayLED1 = 0;
 190   4                      RelayLED2 = 1, RelayLED3 = 0;
 191   4                      break;
 192   4                  case 3:
 193   4                      RelayLED1 = 0;
 194   4                      RelayLED2 = 0, RelayLED3 = 1;
 195   4                      break;
 196   4      
 197   4                  default:
 198   4                      break;
 199   4                  }
 200   3      
 201   3                  if (RelayButton == 1)
 202   3                  {
 203   4                      RelayBuzzer();
 204   4                      switch (relaySetPos)
 205   4                      {
 206   5                      case 1:
 207   5                          Relay1 = (Relay1 == 1 ? 0 : 1);
 208   5                          break;
 209   5                      case 2:
 210   5                          Relay2 = (Relay2 == 1 ? 0 : 1);
 211   5                          break;
 212   5                      case 3:
 213   5                          Relay3 = (Relay3 == 1 ? 0 : 1);
 214   5                          break;
 215   5      
 216   5                      default:
 217   5                          break;
 218   5                      }
 219   4                  }
 220   3      
 221   3                  // 十秒取消
 222   3                  if (Timercount >= 10)
 223   3                  {
 224   4                      settingflag = 0;
 225   4                      WarnLed = 0;
 226   4                  }
 227   3              }
 228   2      
 229   2              /*继电器灯光继承*/
 230   2              RelayLED1 = Relay1;
 231   2              RelayLED2 = Relay2;
 232   2              RelayLED3 = Relay3;
 233   2      
 234   2              Delay_ms(10);
 235   2              // Delay_ms(1000);
 236   2          }
C51 COMPILER V9.59.0.0   MAIN                                                              07/12/2025 04:28:17 PAGE 5   

 237   1          //////////////////////////////////////////
 238   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    719    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----      35
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
